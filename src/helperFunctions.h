#ifndef HELPER_FUNCTIONS_H
#define HELPER_FUNCTIONS_H

#include "esvmTypesDef.h"
#include <fstream>
#include <ctime>

#if defined(WINDOWS) || defined(__WIN32) || defined(_WIN32) || defined(WIN32) && defined(_MSC_VER)
    #pragma warning( disable : 4996 )
#endif

/* -------------------- 
Image paths 
-------------------- */

const std::string roiVideoImagesPath = "../img/roi/";                   // Person ROI tracks obtained from face detection + tracking
const std::string refStillImagesPath = "../img/ref/";                   // Reference high quality still ROIs for enrollment in SSPP
const std::string rootChokePointPath = std::getenv("CHOKEPOINT_ROOT");  // ChokePoint dataset folders location
const std::string roiChokePointPath = rootChokePointPath + "/Cropped face images/"; // Path of extracted 96x96 ROI from all videos 

/* --------------------
Image operations 
-------------------- */

// Reads an image from file and displays it in a small window at the same time
cv::Mat imReadAndDisplay(std::string imagePath, std::string windowName, cv::ImreadModes readMode = cv::IMREAD_GRAYSCALE);
// Translation of an image with XY pixel offset
cv::Mat imTranslate(cv::Mat image, cv::Point offset);
// Flip an image in horizontal/vertital/both directions
enum FlipCode { VERTICAL = 0, HORIZONTAL = 1, BOTH = -1 };
cv::Mat imFlip(cv::Mat image, FlipCode flipCode);
// Returns a vector containing the original image followed by multiple synthetic images generated from the original
std::vector<cv::Mat> imSyntheticGeneration(cv::Mat image);
// Returns a vector containing the patches generated by splitting the image with specified paramters
std::vector<cv::Mat> imSplitPatches(cv::Mat image, cv::Size patchCounts = cv::Size(0, 0));
// Returns a vector of images combining patches splitting and other preprocessing steps (resizing, grayscale, hist.equal., etc.) 
std::vector<cv::Mat> imPreprocess(std::string imagePath, cv::Size imSize, cv::Size patchCounts, 
                                  std::string windowName, cv::ImreadModes readMode = cv::IMREAD_GRAYSCALE);

/* --------------------
Normalization oprations 
-------------------- */

// Min-Max normalization formula
double normalizeMinMax(double value, double min, double max);
// Find the min/max per feature across a whole list of feature vectors
void findMinMaxFeatures(std::vector< FeatureVector > featureVectors, FeatureVector* minFeatures, FeatureVector* maxFeatures);
// Normalization [0, 1] across a feature vector using the corresponding min/max features
FeatureVector normalizeFeatures(FeatureVector featureVectors, FeatureVector minFeatures, FeatureVector maxFeatures);
// Similarity [0, 1] equivalent of class prediction score [-1, 1] by Min-Max rule
inline double normalizeClassScoreToSimilarity(double score) { return (score + 1) / 2; }

/* --------------------
Data Containers
---------------------*/

// Search container for value
template<class C, class T>
inline bool contains(const C& v, const T& x) { return end(v) != std::find(begin(v), end(v), x); }

/* -------------------- 
Logging operations 
-------------------- */

const std::string WINDOW_NAME = "Display";
const std::string LOGGER_FILE = "output.txt";

std::string currentTimeStamp();

class logstream
{
public:    
    std::ofstream coss;
    logstream(std::string filepath);
    ~logstream(void);
    logstream& operator<< (std::ostream& (*pfun)(std::ostream&));
};

template <class T>
logstream& operator<< (logstream& st, T val)
{    
    st.coss << val;
    std::cout << val;
    return st;
}

std::string featuresToVectorString(FeatureVector features);
std::string featuresToSvmString(FeatureVector features, int label);

#endif/*HELPER_FUNCTIONS_H*/